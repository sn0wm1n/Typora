# 引言
## 什么是JVM
定义：  
Java Virtual Machine -java程序的运行环境（java二进制字节码的运行环境）  
JAVA好处  ：  
*一次编写，到处运行  
*自动内存管理，垃圾回收功能  
*数组下标越界检查  
*多态  
比较：
JVM + 基础类库 = JRE + 编译开发工具 = JDK + IDE = 开发JAVASE程序

## 学习JVM有什么用  
*面试  
*理解底层实现原理   自动拆窗项目怎么做  for each怎么实现  动态代理怎么回事    
*中高级程序员的必备技能   内存溢出问题，响应时间缓慢，  

## 常见的JVM  
JVM是一套规范，很多公司有自己的JVM  
课程以hotSpot为准  

# 内存结构
1.程序计数器  
2.虚拟机栈  
3.本地方法栈  
4.堆  
5.方法区  
## 程序计数器  
定义：  
Program Countor Register  
作用：  
jvm指令（二进制字节码）-> 解释器 -> 机器码（0101）-> CPU  
程序计数器会记住下一条指令的执行地址  

特点：  
！线程私有  
！不会存在内存溢出机  

## 虚拟机栈 
JVM STACKS 
### 定义
栈-线程运行的时候需要的内存空间  
栈帧-每个方法运行时需要的内存空间  
活动栈帧-*最顶部的正在执行的方法

感觉线程调用方法以前就是往栈里面放栈帧，如果所有方法是嵌套起来的那么就可以用一个栈执行，初始的方法会最后出栈，可能这就是面向对象的需求来源
**定义相关 小问题**   
*垃圾回收是否涉及栈内存？  
栈内存不会需要垃圾回收，垃圾回收针对堆变量里面的变量   
*栈内存分配的越大越好吗？   
栈越大线程数量越小，  
*方法内部的变量是否线程安全？  
共享的变量需要考虑，私有的不考虑  
如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全  

### 栈内存溢出  
*栈帧过多导致栈内存溢出   比如无限递归，如循环嵌套  异常：stack over flow   
    
*栈帧过大  
*
### 线程运行诊断  
#### 案例一 cpu占用过多解决方案  
*用top定位哪个进程对CPU的占用过高  
##### **ps H -eo pid，tid，%cpu | grep 进程ID**  
（用PS命令进一步定位是那个线程引起cpu占用过高）  
  H 打印的进程数 -eo 规定需要输出哪些感兴趣的内容   
  pid进程ID  tid线程ID  %cpu cpu占用情况   grep筛选进程id 
    
    
    
    

##### *jstack进程ID  
    可以根据线程ID  VCD到有问题的线程，进一步定位到问题代码的源码行号  
    找的时候要进制换算


### 案例二 程序运行很长时间没有结果  
    jstack 进程id 
    运行过后会显示进程ID

## 本地方法栈 Native Method Stacks
**定义：java虚拟机调用本地方法时，需要给本地方法提供的内存空间  
本地方法：不是由java代码编写的方法，一些用c，c++编写的方法，跟操作系统底层api打交道的，java代码可以间接用本地方法来和操作系统底层api打交道  
本地方法举例 ： clone  hashcode notify notifyall wait内部的wait**  

## 堆 Heap
通过new关键字创建对象都会用到堆  
*特点  
线程共享的  需要考虑线程安全问题  
有垃圾回收机制  
### 堆内存溢出
异常名：out of memory error ：java heap space    
-Xmx堆空间更改  
### 堆内存诊断（工具Terminal窗口输入打开）
#### jps工具
*查看当前系统有哪些java进程  

#### jmap工具
*查看堆内存占用情况
jmap -heap 进程id
看 Eden space

#### jconsole工具
*图形界面的，多功能的检测工具，可以连续监测 

#### jvisualvm  （visual machine）
监视选项中的 堆dump 检查，查找

### 案例，垃圾回收后，堆内存占用还是很高 

jvisualvm  （visual machine）   
监视选项中的 堆dump 检查，查找

## 方法区 Method Area

1.6内存结构（永久代）  
方法区在JVM里面，包含常量池（常量池里面有StringTable）class classLoader   

1.8内存结构  （元空间）
方法区在操作系统的内存中，并且只保留常量池（没有StringTable）,class,classLoader  
StringTable放在了堆内存空间  
#### 方法区内存溢出 
因为现在的方法区（元空间）在操作系统的内存比如我的有8G，不好演示，所以去设置java虚拟机参数-XX：MaxMetaspaceSize=8m 演示出了异常  
Out Of Memory Error：Metaspace

换成永久代结构参数是XX：MaxPermSize=
OUt of Memory Error ：PermGen space  

#### 方法区内存溢出场景  
*spring   
*mybatis   
都用到了cglib？？  

### 常量池 

**二进制字节码（类基本信息，常量池，类方法定义（包含虚拟机指令））**  
进入class所在目录， javap -v 文件名.class  

看后面的类方法定义 Code中，上面的操作都是针对常量池内容的，比如成员变量，字符串，方法  

### 运行时常量池  
*常量池就是一张表（上面那里可以看到的表） 虚拟机指令可以根据这个表找到要执行的类名，方法名，参数类型，字面量等信息，
*运行时常量池是*.class文件中的，当该类被加载时，他的常量池信息就会放入运行时的常量池，并把里面的符号地址变为真的地址。  

# StringTable
## 常量池与串池的关系  

```
public class StringTablee {
    public static void main(String[] args) {
        String s1 = "a";
        String s2 = "b";
        String s3 = "ab";
        String s4 = s1+s2;//对象拼接调用了builder拼接好new空间存在堆里了（1.8）
        String s5 = "a"+"b";//编译期间做拼接，确定了所以用的串池，和s3
        相等
    }
}
```
### 注意代码中的注释
常量池存在于字节码文件里，运行时被加载到运行时常量池中去，这时，a，b，ab都是常量池中的符号，还没有变为java字符串对象  
ldc #2 会把a符号变为"a"字符串对象，然后会到StringTable[]（串池，hash表）去找，有就指向串池，没有就创建一个放进串池  
关键点：  
*不用到不会创建对象，只是在字节码里面的符号  
*去找hash表（串池），有就引用，没有就创建  

## 编译优化
就是指字符串常量拼接的原理是编译期优化 
"a"+"b"也会拿去和串池中的"ab"对比，因为它可以在编译期间就确定结果，不像 s1+s2对象拼接调用了builder拼接好new空间存在堆里了  

## intern方法1.8  
可以让String对象调用intern方法，主动将串池中还没有的字符串对象放入串池，不去保存到堆里  
**总结——  首先字符串new出来的都是堆中创建字符串对象，对象名引用的是堆中的对象地址，如果堆中字符串对象想要进入串池需要调用intern()方法，如果放入成功了这个对象自身就会移步串池变成串池里面的相应的对象；**  

**返回——  当串池中没有和他内容相同的字符串时，串池会添加和她内容相同的字符串，同时intern()方法会返回一个串池中的对象（就是放进去的他），反之，当串池中存在和调用intern()的堆对象相同内容的字符串时，串池不会改变，intern()返回串池中和他长得一样的对象**  

**补充：在new字符串对象是参数是直接给了常量"字符串"这种确定的字符串，这个常量字符串会放入串池，但是如果是间接生成的字符串如底层通过append拼接的字符串则不会放入串池，
补充中的补充：回顾上一小节，两个确定的常量字符串相加会在编译期优化被当做拼接过后的起来的常量字符串放入串池。**  


## intern方法1.6 
**补充 之前我的错误理解是1.6结构中的做法，当堆中字符串对象的intern执行，串池没有相同字符串，放入的字符串是用堆中字符串对象复制的对象，也就是说堆中的字符串对象没有改变，方法返回的是复制的对象**


## StringTable位置  
因为StringTable用的十分频繁，永久代的内存回收效率很低，所以把StringTable放在堆中；  

## StringTable垃圾回收机制  
StringTable在内存空间不足时，没有被引用的字符串常量也会被垃圾回收 ，

## StringTable调优 桶的个数 
如果字符常量较多可以更改虚拟机StringTable哈希表的长度，StringTableSize = 桶的个数，减少哈希碰撞加快效率  


# 直接内存
### 定义
操作系统内存  
常见NIO操作时，用于数据缓冲区  
分配回收成本高，但是读写性能高  
不受JVM内存回收管理  

文件读写过程，java不具备读写能力，要调用操作系统本地方法，所以CPU状态会从java用户态调换到内核态，切换到内核态以后，在系统中划一片缓冲区从磁盘里读取，然后在读取到堆内存里的java缓冲区 new byte[] 

NIO当用到direct memory使得系统和java代码可以共享这片区域，速度得到成倍提升

# 落了一部分笔记，可能重看

# 垃圾回收  

## 如何判断对象可以回收
### 引用计数法
根据引用的次数，次数清零则回收，由于循环引用会导致内存泄露，java没采用  

### 可达性分析算法 
java虚拟机采用的垃圾回收算法
先确定肯定不能被当作垃圾回收的根对象，GC Root对象，java会扫描堆中的对象，看是否能够沿着  GC Root对象为起点的引用链找到该对象，找不到表示可以回收，  
哪些对象可以作为GC Root呢？  
弹幕：GCRoots对象包括：  
*虚拟机栈中的局部变量表引用的对象，
*方法区中类静态属性引用和常量引用对象，  
*本地方法栈中的引用的对象   

老师讲的：
*核心类  
*虚拟机调用操作系统方法执行时引用的java类  
*加了锁的对象  
**线程  栈帧内使用的局部变量引用的对象作为根对象**  


可达分析用的jmap方法格式  
jmap -dump：format=b，live，file = 1.bin 21384  
### JVM的四（五）种引用
有哪些哦？  
**强引用 软引用 弱引用 虚引用 终结器引用 **
强引用不会回收  
软引用和弱引用自身就是是被根强引用的对象，具体的对象和这两个对象再通过软弱引用结合  
软引用在内存不足的时候回收   
弱引用必须回收   
——引用队列：  
软引用和弱引用自身是被强引用的，当他们对应的对象被 垃圾回收，这两位被强引用的对象进入引用队列，在需要的时候被变量垃圾回收  

虚引用和终结器引用创建的时候都会管理？一个引用队列，  
虚引用引用的对象被垃圾回收时，为了防止对方在直接内存导致的内存泄漏，虚引用会把自己放在引用队列，间接的用一个线程调用虚引用方法，（方法里面有unsafe.freeMemory）.  

终结期引用： object里面有终结方法，当没有强引用引用对象时，虚拟机就会为这个引用创建终结器引用，当这个对象进行垃圾回收时，把这终结器引用加入引用队列，再由**优先级很低**的一个叫finalize开头的，调用被重写的finalize方法，  
**不推荐**  











## 垃圾回收算法 

## 分带垃圾回收  
## 垃圾回收器
## 垃圾回收调优 